"""Студент: Коробейников Артём Юрьевич на 10 строке
Преподаватель: Кислицин Евгений Вительевич
Дисциплина: Алгоритмы и анализ сложности
Работа: Контрольная или домашняя работа 1
Варианты: 3, 4, 8, 12, 14, 17, 19, 24, 28, 30"""


def task19():
    """Задача 19. Охрана.
Ограничение по времени: 1 с. Ограничение по памяти: 16 Mb.
На секретной военной базе работает N охранников. Сутки поделены на 10000 равных
промежутков времени, и известно когда каждый из охранников приходит на дежурство и
уходит с него. Например, если охранник приходит в 5, а уходит в 8, то значит, что он был в
6, 7 и 8-ой промежуток. В связи с уменьшением финансирования часть охранников решено
было сократить. Укажите: верно ли то, что для данного набора охранников, объект
охраняется в любой момент времени хотя бы одним охранником и удаление любого из них
приводит к появлению промежутка времени, когда объект не охраняется.
Формат входных данных:
В первой строке входного файла INPUT.TXT записано натуральное число K (1 ≤ K
≤ 30) – количество тестов в файле. Каждый тест начинается с числа N (1 ≤ N ≤ 10000), за
которым следует N пар неотрицательных целых чисел A и B - время прихода на дежурство
и ухода (0 ≤ A < B ≤ 10000) соответствующего охранника. Все числа во входном файле
разделены пробелами и/или переводами строки.
Формат выходных данных:
В выходной файл OUTPUT.TXT выведите K строк, где в M-ой строке находится
слово Accepted, если M-ый набор охранников удовлетворяет описанным выше условиям. В
противном случае выведите Wrong Answer.
Примеры:

input.txt
2
3 0 3000 2500 7000 2700 10000
2 0 3000 2700 10000

output6.txt
Wrong Answer
Accepted"""

    # Читаем данные из файла input.txt
    with open("input.txt", "r") as file_in:
        lines = file_in.readlines()
        idx = 0
        results = []

        # Число тестов
        k = int(lines[idx].strip())  # Получаем первое значение K
        idx += 1

        # Обрабатываем тесты
        for test_case in range(k):
            # Количество охранников
            n = int(lines[idx].strip())
            idx += 1

            # Список интервалов охраны каждого охранника
            guards = []
            for _ in range(n):
                guard_times = list(map(int, lines[idx].strip().split()))
                guards.append(guard_times)
                idx += 1

            # Проверяем покрытие всех временных промежутков
            def check_coverage(guards_list):
                coverage = [False] * 10000

                for start, end in guards_list:
                    for t in range(start, end):
                        coverage[t] = True

                return all(coverage)

            # Основной массив покрытия всего периода всеми охранниками
            main_coverage = check_coverage(guards)

            # Если изначальное покрытие неполное, сразу выводим "Wrong Answer"
            if not main_coverage:
                results.append("Wrong Answer")
                continue

            # Теперь проверяем условие удаления каждого охранника
            remove_any_guard_leads_to_gap = True
            for i in range(len(guards)):
                # Создаем копию списка охранников без текущего охранника
                temp_guards = guards[:i] + guards[i + 1:]

                # Проверяем, сохраняется ли полное покрытие
                if check_coverage(temp_guards):
                    remove_any_guard_leads_to_gap = False
                    break

            if remove_any_guard_leads_to_gap:
                results.append("Accepted")
            else:
                results.append("Wrong Answer")

    # Запись результатов в output6.txt
    with open("output6.txt", "w") as file_out:
        file_out.write("\n".join(results))


# Запуск основной функции
if __name__ == "__main__":
    task19()